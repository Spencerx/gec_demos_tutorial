#GEC17 GIMI Tutorial#
##Agenda / Details##
**Use GIMI to instrument, measure, orchestrate, and visualize your GENI experiment**
This tutorial will take you through the steps of initializing, instrumenting, and orchestrating a GENI experiment to enable gathering and visualizing of measurements throughout your experiment.

This tutorial will utilize the following tools: GENI Portal, Labwiki, OMF, OML, and iRODS

**Pre-Requisites**
This is the third part of a [three part tutorial](http://groups.geni.net/geni/wiki/GEC17Agenda/GettingStartedWithGENI). [Part 1](http://groups.geni.net/geni/wiki/GEC17Agenda/GettingStartedWithGENI_I) and [Part 2](http://groups.geni.net/geni/wiki/GEC17Agenda/GettingStartedWithGENI_II) (or equivalent experience) are pre-requisites for this part.

The following background will be helpful for this tutorial:

A basic understanding of GENI concepts such as those covered in the [Introduction to GENI and Experimentation using GENI](http://groups.geni.net/geni/wiki/GEC17Agenda/IntroToGENI) talk prior to this tutorial

**Please Arrive With:**
1. Laptop with a recent version of Virtual Box.
2. A GENI Experimenter Portal account.

**Results**
In Part 3, attendees will add instrumentation and gather their first measurements from a GENI experiment.

At the end of Part 3, attendees will be able to:

+ Use and understand the following terms:
    + OMF
    + OML
    + OEDL
+ Learn how to initialize a GIMI experiment
+ Learn how to use Labwiki to
    + Edit an experiment script written in OEDL
    + Execute an experiment script
    + View live graphs generated by an experiment
    + Document an experiment including live graphs
    + Send measurement data to the GENI Storage and Archive Service

##Experiment Procedure##
###Overview:###
The objective of this tutorial is to introduce the GIMI tool set to experimenters who are interested in performing experiments on ExoGENI slices. We will introduce an experiment workflow which experimenters will most likely apply to perform measurements.

After the tutorial, experimenters should be able to:

+ Create a slice on ExoGENI and run an experiment on top of this slice.
+ Orchestrate experiments with OMF:
    + Set up routing on top of topology
    + Verify that topology has been set up correctly
    + Execute an experiment that measures the impact of packet size on throughput by comparing udp output at the sender and udp input at the receiver.
+ Store and retrieve data to/from iRODS
+ Analyze/visualize measurement data with various tools

###Tools:###

**LabWiki**

It is a tool used to instrumentize and measure network experiments
The project is available on GitHub-LabWiki

**Where to get help:**

You can get solution for most of the ExoGENI problems in the ExoGENI wiki

In the following we list set of resources which experimenters can make use of to obtain further help if required:

+ Mailing list for GIMI users: geni-gimi-users@googlegroups.com
+ Mailing list for ExoGENI users: geni-orca-users@googlegroups.com
**Resources:**

To get more information on [LabWiki](https://github.com/mytestbed/labwiki)

##Design/Setup##

In this part of the tutorial we give a brief overview on the experiment workflow. GIMI is providing experimenters with a set of tools that will aid them in allocating GENI resources (currently this is limited to ExoGENI resources), executing experiments, and performing measurements while these experiments are running. In addition, the GIMI tools will allow experimenters to analyze and visualize measurement data. Finally, a federated set of iRODS servers provides an archival service.
The figure below illustrate what we describe as the experiment workflow. During the tutorial we will walk through the single steps of this workflow with the goal to have experimenters apply this workflow to their own experiments.

###Topology###
The image below illustrates the ExoGENI topology that we will create within the scope of this tutorial. The experiment described above will be executed on the basis of this topology.

In Section 1.Reserving Resources, we will go through the process of setting up and obtaining a slice that represents this topology.

![GIMI_Experiment_Topo.2.png](http://groups.geni.net/geni/attachment/wiki/GEC17Agenda/GettingStartedWithGENI_III_GIMI/Procedure/DesignSetup/GIMI_Experiment_Topo.2.png "")

The routing in this topology is set up as follows:

![gec16-routing.png](/home/cong/Dropbox/SHARED/GENI/GEC/gec16-routing.png "")

###1. Reserve Resources###
####1.1 Login to the [GENI Portal](https://portal.geni.net/)####

####1.2 Select Project and Create Slice ####

create Slice

![ProjectPortal.png](http://groups.geni.net/geni/attachment/wiki/GEC17Agenda/GettingStartedWithGENI_III_GIMI/Procedure/DesignSetup/ProjectPortal.png "")

Give the slice a unique name. Preferably something with your username in it. e.g dbhatlabwiki

![createuniqueslice.png](http://groups.geni.net/geni/attachment/wiki/GEC17Agenda/GettingStartedWithGENI_III_GIMI/Procedure/DesignSetup/createuniqueslice.png "")

####1.3 Click on Add Resources and select RSpec####
Select RSpec from drop down list under Choose Resources. For this tutorial we already have an RSpec created for you. Here, select GIMI_GEC17. 
You can upload your own RSpec. 

![selectRspec.png](http://groups.geni.net/geni/attachment/wiki/GEC17Agenda/GettingStartedWithGENI_III_GIMI/Procedure/DesignSetup/selectRspec.png "")

Here you will need to select the ExoGENI racks assigned to you for the tutorial. This assignment is only done so that we can distribute VMs across different ExoGENI racks. Outside of this tutorial, you can use any of the following racks:

2. 1. FIU ExoGENI
2. GPO ExoGENI
3. ExoGENI ExoSM
4. UH ExoGENI 
5. RENCI ExoGENI 

![selectrspecagg.png](http://groups.geni.net/geni/attachment/wiki/GEC17Agenda/GettingStartedWithGENI_III_GIMI/Procedure/DesignSetup/selectrspecagg.png "")

Click on Reserve Resources
####1.4 Query for resources####
Click on your slice name at the top and click on Resource Status. Once you see a READY on your resources, your slice is ready for experiments. You can refresh the page until you see READY.

Check status 

![resourcestatus.png](http://groups.geni.net/geni/attachment/wiki/GEC17Agenda/GettingStartedWithGENI_III_GIMI/Procedure/DesignSetup/resourcestatus.png "")

Wait until ready 

![readyresource.png](http://groups.geni.net/geni/attachment/wiki/GEC17Agenda/GettingStartedWithGENI_III_GIMI/Procedure/DesignSetup/readyresource.png "")

###2. Configure iRODs###

The iRODs or Integrated Rule-Oriented Datasystem is a directory structure used to archive all experiment related data such as scripts, manifest RSpecs, experiment results and so on.
Please click on this link to learn more iRODs. iRODs has been downloaded and installed on your VMs. 
Please configure your iRODsEnv as explained here:

####2.1 Create iRODs account####
Login to your GENI Portal account and Click on the Profile tab on the top right corner of the page.
At the bottom of the Profile page, click on the Create iRODs button

![iRODscreate.png](http://groups.geni.net/geni/attachment/wiki/GEC17Agenda/GettingStartedWithGENI_III_GIMI/Procedure/DesignSetup/iRODscreate.png "")

####2.2 Configuring iRODs Environment####
You will be redirected to another page with your iRODs Environment and also your temporary iRODs account password.
Copy and paste the contents of the iRODsEnv into ~/.irods/.irodsEnv

Do

    $iinit
    
Enter your temporary password. You can now do

    $ils
    
Sample output:

    dbhat@bua-1159:/usr/local/bin$ ils
    /geniRenci/home/geni-dbhat:
      C- /geniRenci/home/geni-dbhat/dbhat-Explabwiki-2013-07-16T22:11:42
      C- /geniRenci/home/geni-dbhat/dbhat-explast-2013-07-17T00:30:50
      C- /geniRenci/home/geni-dbhat/experimentTemplates
      
You will now see a list of things that are in your iRODs directory. iRODs is now configured. If you are ready to run the Experiment go to Next Step: Execute Experiment

##Execute##
###3. Initial Setup###

####3.1 Starting the OML Server (if needed)####
For this tutorial we have an OML server running on emmy9.casa.umass.edu, which collects the measurement data in an sqlite3 database and at the end of the experiment it pushes the data to IRODS.

+ Here is how you would have to start an OML server if you wanted to run this on a different machine (OML2.8 is required.) DO NOT perform this task in the tutorial.
This is explained the [OML installation file].

        $ /usr/bin/oml2-server -l 3003 --logfile=/var/log/oml2-server-2.9.log --user=oml2 --group=oml2 -H /usr/share/oml2-server/oml2-server-hook.sh
        
    The latest version of OML offers the capability of executing a script after the measurement has finished. In OML terminology this is called a "hook". The hook script we use is attached at the bottom of this wiki page (oml2-server-hook.sh).
    
        #!/bin/bash
        #
        # Example event hook for the OML server, copying an Sqlite database elsewhere
        # when the last client has exited.
        # Copyright 2012-2013 National ICT Australia (NICTA), Australia
        #
        # Permission is hereby granted, free of charge, to any person obtaining a copy
        # of this software and associated documentation files (the "Software"), to deal
        # in the Software without restriction, including without limitation the rights
        # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        # copies of the Software, and to permit persons to whom the Software is
        # furnished to do so, subject to the following conditions:
        #
        # The above copyright notice and this permission notice shall be included in
        # all copies or substantial portions of the Software.
        #
        # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
        # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        # THE SOFTWARE.
        #
        irodsUserName=rods
        irodsHost=emmy9.casa.umass.edu
        irodsPort=1247
        irodsZone=geniRenci
        HOME=/home/oml2
        export irodsUserName irodsHost irodsPort irodsZone HOME
        
        LOGFILE=/tmp/oml2-server-hook.log
        function log ()
        {
        	echo "$@" >&2
        	echo "$@" >> ${LOGFILE}
        }
        
        # XXX: You might need to initialise the iRODS password for the UNIX user
        # running tho oml2-server by running 'iinit' to create ~/.irods/.irodsA on its
        # behalf for iput to work
        IPUT=/usr/bin/iput
        SQLITE3=sqlite3
        PGDUMP=pg_dump
        
        echo "OML HOOK READY"
        log "OML HOOK READY"
        
        while read COMMAND ARGUMENTS; do
        	# One report line must be printed in each control path;
        	# this first one puts out a timestamp and a dump of the received command, but no newline
        	log -n "`date`: ${COMMAND} ${ARGUMENTS}: "
        	case "${COMMAND}" in
        		"DBCLOSED")
        			case "${ARGUMENTS}" in
        				file:*)
        					DBFILE=${ARGUMENTS/file:/}
        					log "${IPUT} ${OPTION} ${DBFILE}"
        					NAME=${DBFILE:14:6};
        					FILE=${DBFILE:14};
        					LENGTH=${#FILE}
        					SLICE=${FILE:0:$LENGTH-4}
        					DATE=`date`
        					log "b db ${DBFILE} closed, pushing to iRODS..."
        					${IPUT} -f ${DBFILE} /geniRenci/home/$NAME/ #$FILE
        					log "an iRODS operation finished"
        					;;
        				postgresql://*)
        					# Separate the components of the URI by gradually eating them off the TMP variable
        					
        					DOMAIN=${ARGUMENTS//*\//}	# cut everything before the final '/'
        					USERNAME=${DOMAIN/-*/}		# get the first part before the '-'
        					REST=${DOMAIN/$USERNAME-/}	# remove the username from the rest
        					EXPNAME=${REST/-*/}		# same as for the username
        					TIMESTAMP=${REST//*-/}		# get the last part after the '-'
        
        						
        					TMP="${ARGUMENTS/postgresql:\/\//}"
        					USER=${TMP/@*/}
        					TMP=${TMP/${USER}@/}
        					HOST=${TMP/:*/}
        					TMP=${TMP/${HOST}:/}
        					PORT=${TMP/\/*/}
        					TMP=${TMP/${PORT}\//}
        					DBNAME=${TMP}
        					DBFILE=${DBNAME}.`date +%Y-%m-%d_%H:%M:%S%z`.pg.sql
        					log "PostgreSQL DB ${DBNAME} closed, dumping as ${DBFILE} and pushing to iRODS"
        					log "User ${USER} Host ${HOST} Port ${PORT} DBNAME ${DBNAME} Home ${HOME}"
        					${PGDUMP} -U ${USER} -h ${HOST} -p ${PORT} ${DBNAME} > /tmp/${DBFILE}
        					log "Before IPUT"
        					log "${IPUT} -f /tmp/${DBFILE} /geniRenci/home/rods/"
        					log `${IPUT} -V -f /tmp/${DBFILE} /geniRenci/home/rods/ 2>&1`
        					# ${IPUT} -f /tmp/${DBFILE} /geniRenci/home/rods/
        					${IPUT} -f /tmp/${DBFILE} /geniRenci/home/${USERNAME}/experiments/${EXPNAME}-${TIMESTAMP}/measurements.sql
        					log "After IPUT"
        					;;
        				*)
        					log "DB ${ARGUMENTS} closed, but don't know how to handle it"
        					;;
        			esac
        			;;
        		"EXIT")
        			log "Exiting"
        			exit 0
        			;;
        		*)
        			log "Unknown command"
        			;;
        	esac
        done
        
###3.2 Verification of Topology###
After establishing the slice on which the experiment will be executed, the experimenter will be most likely be interested in verifying if the slice has been initiated correctly. In this tutorial, we use an [OMF experiment script] that executes pings between neighboring nodes. 

The following figure shows that a total of 12 (between each pair of nodes and in each direction) ping are performed.

![ping.png](http://groups.geni.net/geni/attachment/wiki/GEC17Agenda/GettingStartedWithGENI_III_GIMI/Procedure/Execute/ping.png "")

    defProperty('source1', "nodeA", "ID of a resource")
    defProperty('source2', "nodeB", "ID of a resource")
    defProperty('source3', "nodeC", "ID of a resource")
    defProperty('source4', "nodeD", "ID of a resource")
    defProperty('source5', "nodeE", "ID of a resource")
    
    #defProperty('sink1', "nodeA", "ID of a sink")
    #defProperty('sink2', "nodeB", "ID of a sink")
    #defProperty('sink3', "nodeC", "ID of a sink")
    #defProperty('sink4', "nodeD", "ID of a sink")
    #defProperty('sink5', "nodeE", "ID of a sink")
    
    defProperty('sinkaddr11', '192.168.4.10', "Ping destination address")
    defProperty('sinkaddr12', '192.168.5.12', "Ping destination address")
    
    defProperty('sinkaddr21', '192.168.4.11', "Ping destination address")
    defProperty('sinkaddr22', '192.168.2.12', "Ping destination address")
    defProperty('sinkaddr23', '192.168.1.13', "Ping destination address")
    
    defProperty('sinkaddr31', '192.168.5.11', "Ping destination address")
    defProperty('sinkaddr32', '192.168.2.10', "Ping destination address")
    defProperty('sinkaddr33', '192.168.3.13', "Ping destination address")
    defProperty('sinkaddr34', '192.168.6.14', "Ping destination address")
    
    defProperty('sinkaddr41', '192.168.1.10', "Ping destination address")
    defProperty('sinkaddr42', '192.168.3.12', "Ping destination address")
    
    defProperty('sinkaddr51', '192.168.6.12', "Ping destination address")
    
    defApplication('ping_app', 'pingmonitor') do |a|
        a.path = "/root/pingWrap.rb" 
        a.version(1, 2, 0)
        a.shortDescription = "Wrapper around ping" 
        a.description = "ping application"
        a.defProperty('dest_addr', 'Address to ping', '-a', {:type => :string, :dynamic => false})
        a.defProperty('count', 'Number of times to ping', '-c', {:type => :integer, :dynamic => false}) 
        a.defProperty('interval', 'Interval between pings in s', '-i', {:type => :integer, :dynamic => false})
    
        a.defMeasurement('myping') do |m|
         m.defMetric('dest_addr',:string) 
         m.defMetric('ttl',:int)
         m.defMetric('rtt',:float)
         m.defMetric('rtt_unit',:string)
       end
    end
    
    defGroup('Source1', property.source1) do |node|
      node.addApplication("ping_app") do |app|
        app.setProperty('dest_addr', property.sinkaddr11)
        app.setProperty('count', 30)
        app.setProperty('interval', 1)
        app.measure('myping', :samples => 1)
      end
    
      node.addApplication("ping_app") do |app|
        app.setProperty('dest_addr', property.sinkaddr12)
        app.setProperty('count', 30)
        app.setProperty('interval', 1)
        app.measure('myping', :samples => 1)
      end
    end
    
    defGroup('Source2', property.source2) do |node|
      node.addApplication("ping_app") do |app|
        app.setProperty('dest_addr', property.sinkaddr21)
        app.setProperty('count', 30)
        app.setProperty('interval', 1)
        app.measure('myping', :samples => 1)
      end
    
      node.addApplication("ping_app") do |app|
        app.setProperty('dest_addr', property.sinkaddr22)
        app.setProperty('count', 30)
        app.setProperty('interval', 1)
        app.measure('myping', :samples => 1)
      end
    
      node.addApplication("ping_app") do |app|
        app.setProperty('dest_addr', property.sinkaddr23)
        app.setProperty('count', 30)
        app.setProperty('interval', 1)
        app.measure('myping', :samples => 1)
      end
    end
    
    defGroup('Source3', property.source3) do |node|
      node.addApplication("ping_app") do |app|
        app.setProperty('dest_addr', property.sinkaddr31)
        app.setProperty('count', 30)
        app.setProperty('interval', 1)
        app.measure('myping', :samples => 1)
      end
    
      node.addApplication("ping_app") do |app|
        app.setProperty('dest_addr', property.sinkaddr32)
        app.setProperty('count', 30)
        app.setProperty('interval', 1)
        app.measure('myping', :samples => 1)
      end
    
      node.addApplication("ping_app") do |app|
        app.setProperty('dest_addr', property.sinkaddr33)
        app.setProperty('count', 30)
        app.setProperty('interval', 1)
        app.measure('myping', :samples => 1)
      end
    
      node.addApplication("ping_app") do |app|
        app.setProperty('dest_addr', property.sinkaddr34)
        app.setProperty('count', 30)
        app.setProperty('interval', 1)
        app.measure('myping', :samples => 1)
      end
    end
    
    defGroup('Source4', property.source4) do |node|
    
      node.addApplication("ping_app") do |app|
        app.setProperty('dest_addr', property.sinkaddr41)
        app.setProperty('count', 30)
        app.setProperty('interval', 1)
        app.measure('myping', :samples => 1)
      end
    
      node.addApplication("ping_app") do |app|
        app.setProperty('dest_addr', property.sinkaddr42)
        app.setProperty('count', 30)
        app.setProperty('interval', 1)
        app.measure('myping', :samples => 1)
      end
    end
    
    defGroup('Source5', property.source5) do |node|
      node.addApplication("ping_app") do |app|
        app.setProperty('dest_addr', property.sinkaddr51)
        app.setProperty('count', 30)
        app.setProperty('interval', 1)
        app.measure('myping', :samples => 1)
      end
    end
    
    onEvent(:ALL_UP_AND_INSTALLED) do |event|
      info "Starting the ping"
      allGroups.startApplications
      wait 5
      info "Stopping the ping"
      allGroups.stopApplications
      Experiment.done
    end
    
####3.3 Setup Routing in Experiment Topology####

In more complex topologies routing has to be set up. In our case, this is achieved with the aid of an [OMF experiment script]. The one we use for this tutorial is shown below.

    defGroup('Node1', "nodeA")
    defGroup('Node2', "nodeB")
    defGroup('Node3', "nodeC")
    defGroup('Node4', "nodeD")
    defGroup('Node5', "nodeE")
    
    
    onEvent(:ALL_UP) do |event|
      wait 1
      info 'Changing routing setup'
    
      group('Node1').exec("route add -net 192.168.1.0/24 gw 192.168.4.10")
      group('Node1').exec("route add -net 192.168.2.0/24 gw 192.168.4.10")
      group('Node1').exec("route add -net 192.168.3.0/24 gw 192.168.5.12")
      group('Node1').exec("route add -net 192.168.6.0/24 gw 192.168.5.12")
      group('Node1').exec("echo 1 >  /proc/sys/net/ipv4/ip_forward")
    
      group('Node2').exec("route add -net 192.168.3.0/24 gw 192.168.1.13")
      group('Node2').exec("route add -net 192.168.5.0/24 gw 192.168.4.11")
      group('Node2').exec("route add -net 192.168.6.0/24 gw 192.168.2.12")
      group('Node2').exec("echo 1 >  /proc/sys/net/ipv4/ip_forward")
    
      group('Node3').exec("route add -net 192.168.1.0/24 gw 192.168.3.13")
      group('Node3').exec("route add -net 192.168.4.0/24 gw 192.168.5.11")
      group('Node3').exec("echo 1 >  /proc/sys/net/ipv4/ip_forward")
    
      group('Node4').exec("route add -net 192.168.2.0/24 gw 192.168.3.12")
      group('Node4').exec("route add -net 192.168.4.0/24 gw 192.168.1.10")
      group('Node4').exec("route add -net 192.168.5.0/24 gw 192.168.3.12")
      group('Node4').exec("route add -net 192.168.6.0/24 gw 192.168.3.12")
      group('Node4').exec("echo 1 >  /proc/sys/net/ipv4/ip_forward")
    
      group('Node5').exec("route add -net 192.168.2.0/24 gw 192.168.6.12")
      group('Node5').exec("route add -net 192.168.1.0/24 gw 192.168.6.12")
      group('Node5').exec("route add -net 192.168.3.0/24 gw 192.168.6.12")
      group('Node5').exec("route add -net 192.168.4.0/24 gw 192.168.6.12")
      group('Node5').exec("route add -net 192.168.5.0/24 gw 192.168.6.12")
    
      info 'Routing setup finished'
      wait 5
      info 'Stopping applications'
      allGroups.stopApplications
      wait 1
      Experiment.done
    end
    
This script can be easily adapted if the experimenter wishes to set up the routing between the nodes differently.

####3.4 Verification of Routing####

After establishing the routing, we use an [OMF experiment script] that executes pings between each pair of nodes that contains one hop, to verify the correctness of routing setup.

![GIMIPing_e2e.png](http://groups.geni.net/geni/attachment/wiki/GEC17Agenda/GettingStartedWithGENI_III_GIMI/Procedure/Execute/GIMIPing_e2e.png "")

    defProperty('source1', "nodeA", "ID of a resource")
    defProperty('source2', "nodeB", "ID of a resource")
    defProperty('source3', "nodeC", "ID of a resource")
    defProperty('source4', "nodeD", "ID of a resource")
    defProperty('source5', "nodeE", "ID of a resource")
    
    defProperty('sinkaddr11', '192.168.1.13', "Ping destination address")
    defProperty('sinkaddr12', '192.168.3.13', "Ping destination address")
    defProperty('sinkaddr13', '192.168.6.14', "Ping destination address")
    
    defProperty('sinkaddr21', '192.168.6.14', "Ping destination address")
    
    defProperty('sinkaddr41', '192.168.4.11', "Ping destination address")
    defProperty('sinkaddr42', '192.168.5.11', "Ping destination address")
    defProperty('sinkaddr43', '192.168.6.14', "Ping destination address")
    
    defProperty('sinkaddr51', '192.168.5.11', "Ping destination address")
    defProperty('sinkaddr52', '192.168.2.10', "Ping destination address")
    defProperty('sinkaddr53', '192.168.3.13', "Ping destination address")
    
    defApplication('ping_app', 'pingmonitor') do |a|
            a.path = "/root/pingWrap.rb"
            a.version(1, 2, 0)
            a.shortDescription = "Wrapper around ping"
            a.description = "ping application"
            a.defProperty('dest_addr', 'Address to ping', '-a', {:type => :string, :dynamic => false})
            a.defProperty('count', 'Number of times to ping', '-c', {:type => :integer, :dynamic => false})
            a.defProperty('interval', 'Interval between pings in s', '-i', {:type => :integer, :dynamic => false})
            
            a.defMeasurement('myping') do |m|
                m.defMetric('dest_addr',:string)
                m.defMetric('ttl',:int)
                m.defMetric('rtt',:float)
                m.defMetric('rtt_unit',:string)
            end
    end
    
    defGroup('Source1', property.source1) do |node|
          node.addApplication("ping_app") do |app|
              app.setProperty('dest_addr', property.sinkaddr11)
              app.setProperty('count', 30)
              app.setProperty('interval', 1)
              app.measure('myping', :samples => 1)
          end
          
          node.addApplication("ping_app") do |app|
              app.setProperty('dest_addr', property.sinkaddr12)
              app.setProperty('count', 30)
              app.setProperty('interval', 1)
              app.measure('myping', :samples => 1)
          end
    
          node.addApplication("ping_app") do |app|          
              app.setProperty('dest_addr', property.sinkaddr13)
              app.setProperty('count', 30)              
              app.setProperty('interval', 1)                  
              app.measure('myping', :samples => 1)
          end
    end
    
    defGroup('Source2', property.source1) do |node|
        node.addApplication("ping_app") do |app|              
            app.setProperty('dest_addr', property.sinkaddr21)        
            app.setProperty('count', 30)            
            app.setProperty('interval', 1)                
            app.measure('myping', :samples => 1)                  
        end                
    end
    
    defGroup('Source4', property.source3) do |node|
          node.addApplication("ping_app") do |app|
              app.setProperty('dest_addr', property.sinkaddr41)
              app.setProperty('count', 30)
              app.setProperty('interval', 1)
              app.measure('myping', :samples => 1)
          end
    
          node.addApplication("ping_app") do |app|
              app.setProperty('dest_addr', property.sinkaddr42)
              app.setProperty('count', 30)
              app.setProperty('interval', 1)
              app.measure('myping', :samples => 1)
          end
    
          node.addApplication("ping_app") do |app|
              app.setProperty('dest_addr', property.sinkaddr43)
              app.setProperty('count', 30)
              app.setProperty('interval', 1)
              app.measure('myping', :samples => 1)
          end
    end
    
    defGroup('Source5', property.source3) do |node|
              node.addApplication("ping_app") do |app|
                  app.setProperty('dest_addr', property.sinkaddr51)
                  app.setProperty('count', 30)
                  app.setProperty('interval', 1)
                  app.measure('myping', :samples => 1)
              end
    
              node.addApplication("ping_app") do |app|
                  app.setProperty('dest_addr', property.sinkaddr52)
                  app.setProperty('count', 30)
                  app.setProperty('interval', 1)
                  app.measure('myping', :samples => 1)
              end
    
              node.addApplication("ping_app") do |app|
                  app.setProperty('dest_addr', property.sinkaddr53)
                  app.setProperty('count', 30)
                  app.setProperty('interval', 1)
                  app.measure('myping', :samples => 1)
              end
    end
    
    onEvent(:ALL_UP_AND_INSTALLED) do |event|
          info "Starting the ping"
          allGroups.startApplications
          wait 5
          info "Stopping the ping"
          allGroups.stopApplications
          Experiment.done
    end
    
###4. Running Actual Experiment###

We will use an [OMF experiment script] to execute oml enabled traffic generator and receiver (otg and otr) to simulate network traffic, and use oml enabled nmetrics to measure the system usage (e.g., CUP, memory) and network interface usage on each of the participated ExoGENI nodes.

![otg_nmetrics.png](http://groups.geni.net/geni/attachment/wiki/GEC17Agenda/GettingStartedWithGENI_III_GIMI/Procedure/Execute/otg_nmetrics.png "")

The one we use for this tutorial is shown below.

    defProperty('theSender','nodeB','ID of sender node')
    defProperty('theReceiver1', 'nodeE', "ID of receiver node")
    defProperty('theReceiver2', 'nodeA', "ID of receiver node")
    defProperty('theReceiver3', 'nodeD', "ID of receiver node")
    defProperty('packetsize', 128, "Packet size (byte) from the sender node")
    defProperty('bitrate', 2048, "Bitrate (bit/s) from the sender node")
    defProperty('runtime', 40, "Time in second for the experiment is to run")
    
    defGroup('Sender',property.theSender) do |node|
        options = { 'sample-interval' => 2 }
        node.addPrototype("system_monitor", options)
        node.addApplication("test:app:otg2") do |app|
            app.setProperty('udp:local_host', '192.168.2.10')
            app.setProperty('udp:dst_host', '192.168.6.14')
            app.setProperty('udp:dst_port', 3000)
            app.setProperty('cbr:size', property.packetsize)
            app.setProperty('cbr:rate', property.bitrate * 2)
            app.measure('udp_out', :samples => 1)
        end
        
        node.addApplication("test:app:otg2") do |app|
            app.setProperty('udp:local_host', '192.168.4.10')
            app.setProperty('udp:dst_host', '192.168.4.11')
            app.setProperty('udp:dst_port', 3000)
            app.setProperty('cbr:size', property.packetsize)
            app.setProperty('cbr:rate', property.bitrate * 2)
            app.measure('udp_out', :samples => 1)
        end
        
        node.addApplication("test:app:otg2") do |app|
            app.setProperty('udp:local_host', '192.168.1.10')
            app.setProperty('udp:dst_host', '192.168.1.13')
            app.setProperty('udp:dst_port', 3000)                                    
            app.setProperty('cbr:size', property.packetsize)                                            
            app.setProperty('cbr:rate', property.bitrate * 2)                                                    
            app.measure('udp_out', :samples => 1)                                                        
        end
    end
    
    defGroup('Receiver1',property.theReceiver1) do |node|
        options = { 'sample-interval' => 2 }
        node.addPrototype("system_monitor", options)
    
        node.addApplication("test:app:otr2") do |app|
            app.setProperty('udp:local_host', '192.168.6.14')
            app.setProperty('udp:local_port', 3000)
            app.measure('udp_in', :samples => 1)
        end
    end
    
    defGroup('Receiver2',property.theReceiver2) do |node|
        options = { 'sample-interval' => 2 }
        node.addPrototype("system_monitor", options)
        node.addApplication("test:app:otr2") do |app|
            app.setProperty('udp:local_host', '192.168.4.11')
            app.setProperty('udp:local_port', 3000)
            app.measure('udp_in', :samples => 1)
        end 
    end
    
    defGroup('Receiver3',property.theReceiver3) do |node|     
        options = { 'sample-interval' => 2 }
        node.addPrototype("system_monitor", options)
        node.addApplication("test:app:otr2") do |app|                    
            app.setProperty('udp:local_host', '192.168.1.13')
            app.setProperty('udp:local_port', 3000)                                
            app.measure('udp_in', :samples => 1)                                    
        end
    end
    
    onEvent(:ALL_UP_AND_INSTALLED) do |event|
        info "starting"
        wait 5
        allGroups.exec("ln -s /usr/local/bin/otr2 /usr/bin/otr2")
        allGroups.exec("ln -s /usr/local/bin/otg2 /usr/bin/otg2")
        allGroups.exec("ln -s /usr/local/bin/oml2-nmetrics /usr/bin/oml2-nmetrics")
        allGroups.startApplications
        info "All applications started..."
        wait property.runtime / 4
        property.packetsize = 256
        wait property.runtime / 4
        property.packetsize = 512
        wait property.runtime / 4
        property.packetsize = 1024
        wait property.runtime / 4
        allGroups.stopApplications
        info "All applications stopped." 
        Experiment.done
    end
    
###5. LabWiki###

LabWiki is a tool which provides a user-friendly interface to visualize your experiment. To know more about LabWiki please visit [LabWiki](https://github.com/mytestbed/labwiki)
LabWiki can be used to Plan, Prepare and Run your Experiment.

####5.1 Login using OpenID####
If you are logged in to the GENI Portal you will be logged in to LabWiki automatically when you click Login. 

*Otherwise please enter the same username and password you use for the GENI Portal*
There is a link to LabWiki now available through the GENI Portal or you can click [here](http://labwiki.casa.umass.edu:4000/) to use LabWiki

![Labwiki_OpenID.png](http://groups.geni.net/geni/attachment/wiki/GEC17Agenda/GettingStartedWithGENI_III_GIMI/Procedure/Execute/Labwiki_OpenID.png "")

Figure (1)

Send your information. This allows LabWiki to use the GENI Portal ID to log you in to LabWiki.

![Labwiki_sendinfo.png](http://groups.geni.net/geni/attachment/wiki/GEC17Agenda/GettingStartedWithGENI_III_GIMI/Procedure/Execute/Labwiki_sendinfo.png "")

Figure (2)

####5.2 Plan####

After you have successfully been signed in you will be able to see a screen like the one below. 

![Labwiki_1.png](http://groups.geni.net/geni/attachment/wiki/GEC17Agenda/GettingStartedWithGENI_III_GIMI/Procedure/Execute/Labwiki_1.png "")

Figure (3)

The left column could contain the steps to run the experiment or general information about the experiment.
The scripts are written using a simple [markdown](http://daringfireball.net/projects/markdown/syntax) scripts.

![Labwiki_2.png](http://groups.geni.net/geni/attachment/wiki/GEC17Agenda/GettingStartedWithGENI_III_GIMI/Procedure/Execute/Labwiki_2.png "")

Figure (4)

5.3 Prepare

In the Prepare column, you can select the experiment that you want to execute. In this column you will also be able to edit your experiment script.

![Labwiki_4.png](http://groups.geni.net/geni/attachment/wiki/GEC17Agenda/GettingStartedWithGENI_III_GIMI/Procedure/Execute/Labwiki_4.png "")

Figure (5)

After editing, click on the save icon at the top of the column to save your script. 
Next, click and drag the icon at the top left corner over to the right column Execute.

####5.4 Execute####

Here, you can start your experiment and Visualise it. In the name tab, type in the name you wish to give the experiment. Your name should only consist of alphanumeric characters. Only '_' is allowed as a special character.

**5.4.1 Add a Context**

If you do not want to create a new context, skip this step. 
At the top-right corner there is a button called 'Add Context'. This allows you to create an Experiment context which can be useful when you want to store related experiments in the same folder with associated metadata. This Context can then be browsed using the iRODs web interface. 
Give the context a name, as shown below and click on 'Save': 

![Labwiki_15.png](http://groups.geni.net/geni/attachment/wiki/GEC17Agenda/GettingStartedWithGENI_III_GIMI/Procedure/Execute/Labwiki_15.png "")

Figure (6)

**5.4.2 Run Experiment**

Give your task a name. Select the Project, Experiment Context and Slice from the drop down menu on the screen.
Then scroll towards the bottom of this column and under the tab named Graph, type 'true'.This enables the graph view on your execute column.
Once the experiment starts running you will be able to scroll down and view the graph.

![Labwiki_16.png](http://groups.geni.net/geni/attachment/wiki/GEC17Agenda/GettingStartedWithGENI_III_GIMI/Procedure/Execute/Labwiki_16.png "")

Figure (7)

Click on 'Start Experiment' at the bottom of the screen.

![Labwiki_19.png](http://groups.geni.net/geni/attachment/wiki/GEC17Agenda/GettingStartedWithGENI_III_GIMI/Procedure/Execute/Labwiki_19.png "")

Figure (8)

After a couple of seconds, you can see the graph at the bottom of the screen.
At any point during the run of your experiment, click on Dump at the top of the Execute column to save your experiment data in iRODs.
You can click and drag it to the Plan screen just above Figure 1. This will display the graph along with the experiment description. This graph is also dynamic.
This allows you to add any comments or details about the experiment results.
Similarly, Experiments 2 and 3 can be run using the same procedure. Experiment 2 does not have a graph.

![Labwiki_12.png](http://groups.geni.net/geni/attachment/wiki/GEC17Agenda/GettingStartedWithGENI_III_GIMI/Procedure/Execute/Labwiki_12.png "")

Figure(9)

Once you have your slice up and running you can visualize any experiment using LabWiki.

##Finish##
###6. Delete Slice###
Once you are finished with your experiment, you could make them available to other experimenters by deleting your resources.
This can be done from teh GENI Portal page or through Omni.

Delete your resources as shown:

![deleteresources.png](http://groups.geni.net/geni/attachment/wiki/GEC17Agenda/GettingStartedWithGENI_III_GIMI/Procedure/Finish/deleteresources.png "")

###7. View data in iRODs ###

To login it to iDrop, which allows you to view your iRODs data in the browser, click here . Enter your iRODs username and password from the GENI Portal.

![iDroplogin.png](http://groups.geni.net/geni/attachment/wiki/GEC17Agenda/GettingStartedWithGENI_III_GIMI/Procedure/Finish/iDroplogin.png "")

Click [here](http://wimax.orbit-lab.org/wiki/WiMAX/GIMIUse#Viewandanalyzeresults) to learn how to plot your data directly from iRODs.